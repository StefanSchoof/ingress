package wiring

import (
	"strings"

	"github.com/andig/ingress/pkg/api"
	"github.com/andig/ingress/pkg/log"
)

// Mapper handles data transfer over wires
type Mapper struct {
	wiring     *Wiring
	connectors *Connectors
}

// NewMapper creates a data mapper that is able to Process() input messages
// by sending them to configured output wires
func NewMapper(wiring *Wiring, conn *Connectors) *Mapper {
	mapper := &Mapper{
		wiring:     wiring,
		connectors: conn,
	}
	return mapper
}

// Process data generated by data source by passing to all wired data targets
func (m *Mapper) Process(source string, d api.Data) {
	d.Normalize() // normalize data before sending to any target

	for _, wire := range m.wiring.WiresForSource(source) {
		log.Context(
			log.EV, d.Name(),
			log.SRC, wire.Source,
			log.TGT, wire.Target,
		).Debug("routing")

		// map and publish async
		go m.processWire(&wire, d)
	}
}

// async function for publishing
func (m *Mapper) processWire(wire *Wire, d api.Data) {
	mapped := m.processMappings(wire, d)
	if mapped == nil {
		return
	}

	target, err := m.connectors.TargetForName(wire.Target)
	if err != nil {
		log.Fatal("invalid target " + wire.Target)
		return
	}

	target.Publish(d)
}

func (m *Mapper) processMappings(wire *Wire, d api.Data) api.Data {
	if len(wire.Mappings) == 0 {
		return d
	}

	dataName := strings.ToLower(d.Name())
	for mappingName, mapping := range wire.Mappings {
		for _, entry := range mapping {
			if dataName == strings.ToLower(entry.From) {
				log.Context(
					log.EV, d.Name(),
					"mapping", mappingName,
				).Debugf("mapping %s -> %s ", d.Name(), entry.To)
				d.SetName(entry.To)
				return d
			}
		}
	}

	// not mapped
	log.Context(log.EV, d.Name()).Debugf("no mapping - dropped")
	return nil
}
