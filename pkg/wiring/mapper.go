package wiring

import (
	"fmt"
	"log"
	"strings"
	"sync/atomic"

	"github.com/andig/ingress/pkg/config"
	"github.com/andig/ingress/pkg/data"
)

type wire struct {
	input  string
	output string
}

type Mapper struct {
	wirings   []wire
	publisher PublisherMap
	inflight  int64 // number of inflight requests
}

// NewMapper creates a data mapper that is able to Process() input messages
// by sending them to configured output wires
func NewMapper(c []config.Wiring, conn *Connectors) *Mapper {
	wirings := make([]wire, 0)
	for _, wiring := range c {
		for _, input := range wiring.Inputs {
			if _, ok := conn.Input[input]; !ok {
				panic(fmt.Sprintf("mapper: cannot wire %s -> *, source not defined", input))
			}

			for _, output := range wiring.Outputs {
				if _, ok := conn.Output[output]; !ok {
					panic(fmt.Sprintf("mapper: cannot wire %s -> %s, target not defined", input, output))
				}

				m := strings.Join(wiring.Mapping, ",")
				log.Printf("mapper: wiring %s -> %s using %s", input, output, m)

				wire := wire{input, output}
				wirings = append(wirings, wire)
			}
		}
	}

	mapper := &Mapper{
		wirings:   wirings,
		publisher: conn.Output,
	}
	return mapper
}

// Process data generated by source by passing to all affected targets
func (m *Mapper) Process(source string, d *data.Data) {
	if d.Timestamp == 0 {
		log.Printf("mapper: received timestamp=0 from %s", d.Name)
		d.Timestamp = data.Timestamp()
	}

	mapped := false
	for _, wiring := range m.wirings {
		if wiring.input == source {
			mapped = true

			publisher, ok := m.publisher[wiring.output]
			if !ok {
				log.Println("mapper: invalid target " + wiring.output)
				continue
			}

			log.Printf("mapper: routing %s -> %s ", wiring.input, wiring.output)

			// publish async
			go func(d *data.Data) {
				atomic.AddInt64(&m.inflight, 1)
				publisher.Publish(*d)
				atomic.AddInt64(&m.inflight, -1)
			}(d)
		}
	}

	if !mapped {
		// log.Println("mapper: invalid source " + d.Source)
	}
}
